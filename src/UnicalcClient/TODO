Если кто-то когда-то еще будет делать какие-то клиентики уникалька на основе кода, который я оставил, то вот некоторые вещи,
которые было бы очень хорошо сделать для улучшения этого небольшого движка и мои оценки того насколько сложно/долго сделать то или иное улучшение.
Итак:
- Нумерация строк в обозревателе .uni файлов [легко-средне сложно]
    Когда в результате вычислений с сервера приходит что то типа "Compiling errors ...", то там содержится только номер строки и довольно сложно понять в чем дело, если нету никакого контроля корректности входных данных.
    Бороться с этим помог бы просмотр текста самого .uni файла. Эта функция уже есть, но без нумерации строк она не очень полезна.
    В офицальной документации есть готовый пример того как можно добавить нумерацию строк: с ним надо только разобраться и адатировать под класс UniFileViewer.
    http://doc.qt.io/qt-5/qtwidgets-widgets-codeeditor-example.html
- Специальный класс для считывания .uni файлов вместо примитивного getValue(?) [Наверное, сложно, если делать как я предлагаю]
    Для считывания .uni файлов сейчас используется примитивнейшкая функция getValue из ForUniAndVal.hpp.
    Она работает, но она плоха всем:
        * Для считывания каждого поля она присматривает файл заново, что может вызвать на очень больших моделях серьезные подвивания при загрузке, но это еще не так страшно.
        * Она не умеет распознавать файлы, которые не были отформатированные специально для нее, т.к. лишний пробел или комментарий приводит к тому, что она не может найти поле или считает значение комментария.
        * В следствии предыдущего при вводе индексной величины даже приходится каждый раз генерировать строку названия переменной, т.к. сейчас скобка с индексом - это тоже честь названия.
        * При вводе модели надо сначала вводить значения полей, которые должен вводить пользователь, а только потом связи или может произойти нехорошая штука
            x = 42;                              x = 42;                                        x = 42;
            y = [-100;100];                      y = [-100;100];                                y = [-100;100];
            z = [-100;100];                      z = y+x;                                       z=y+x;
            z = y+x;                             z = [-100;100];                                z = [-100;100];
            ||                                  ||                                              ||
            ||  Считываем x, y, z               || Считываем x, y, z                            || Считываем x, y, z
            \/                                  \/                                              \/
            x=42                                x=42                                            x=42
            y=[-100;100];                       y=[-100;100]                                    y=[-100;100]
            z=[-100;100];                       z=y+x                                           z=[-100;100]
            В полях ввода все ок.               Соблюдали прихоти getValue, а получили          Все ок, но нам либо повезло,
                                                условие связи из модели вместо значения.        либо мы так специально хитро сделали, чтобы считалось как надо.
    Не думаю, что проблему первого и второго примера, можно решить наверняка в какой-то лучшей реализации getValue, но кое-что сделать можно...
    ГРУБЫЙ НАБРОСОК МЕТОДА ВВОДА UNI ФАЙЛОВ(не претендую на то, что это лучшая замена getValue или вообще не что-то вроде стрельбы из пушки по воробьям)
        Создаем класс, который принимает в конструкторе строку с содержанием .uni файла.
        Этот класс должен создаваться выдавать и значение параметра, когда его просят это сделать, за хорошее время (n и nlogn соотв. от кол-ва параметров).
        Ввод делаем одноразовым проходом по содержимому файла:
            Запоминаем текущую позицию в файле(i)
            Двигаемся дальше пока не встретим разделитель в позиции j (';'или ' ' в зависимости от того uni или val файл это. Знание об этом надо бы передать в конструктор класса)
            Обрабатываем(это дальше) подстроку от i до j, чтобы вставить ее в струкуру, в которой храним данные. Самое логичное - это использовать двоичное дерево для хранения данных в классе.
            Следующая итерация с позиции j.
        Так делаем пока есть что считывать до того как упремся в k=индексу первого вхождения строки (*УРАВНЕНИЯ СВЯЗЕЙ*) после которого начинаются уравнения связей, которые нам неинтересны.
        При обработке подстроки, содержащей имя параметра, его индексы и значения надо сначала удалить все вхождения комментариев из нее (*...*) и всякие лишние символы, вроде переносов строки или незначащих пробелов до знака '='.
        Потом надо выделить имя переменной и записать в var::name и последовательно все индексы в var::index, и само значение после '=' в var::val.
        Сделать считывание имени и индексов в скобках так, чтобы не обращать внимания на незначащие пробелы довольно легко за O(str_len). Теперь эту переменную(varwithval) надо вставить в дерево.
        Для сортировки используем сравнение a<b <=> a.name < b.name или (a.name = b.name и a.index[0]=b.index[0] и ... и a.index[t-1]=b.index[t-1] и a.index[t]<b.index[t]) (сортировка сначала по имени, потом последовательно по индексам, если надо.)
        Придумать что делать при неправильных входных данных, вроде наличия одновременно a[0]=1 и a[0][1]=2.
        Значение конкретной величины потом легко извлечь бинарным поиском за nlogn, когда виджет будет просить значение переменной, которую просят в виде class.
    Таким образом, получили класс, который позволяет удобно и быстро считывать файлы и получать доступ к данным по строке названия и списку индексов(var("array", list() << 1 << 3 << 4) и var("var")).
    class var
    {
        var(QStringRef str);
        var(QString name, QstringList index = QstringList());//удобный не привередливый конструктор для использования в виджетах ввода/вывода, чтобы сделать запрос значения переменной.
        friend bool operator<(const var& l, const var& r);
        Qstring name;
        QstringList index;
    }
    class varwithval: public var
    {
        varwithval(var var, Qstring val):  var(var), val(val)
        {}
        Qstring val;
    }
    class uni: private sometree<varwithval>
    {
        uni(Qstring unifile);
        Qstring val(var v);//поиск в девеве
    private:
        varwithval proces(QStringRef);//по подстроке получить название переменной, список индексов, если величина индексная и строку значения.
        insertintree(varwithval );//вставка в двоичное дерево
    }
- Хорошо добавить в виджеты конкретных задач обработку ситуации, когда какой-то параметр отсутствует в .uni файле или нам нужно всего n переменных, а класс, говорит, что в нем n+m разных переменных(т.е что-то точно лишнее или дублирующееся) [легко]
- Какая то логика в порядке подключения инклудов. По алфавиту, по <>/"", по чему-то еще. Также проверить единообразие стиля кода. [легко]
- Наврное, правильно будет вместо virtual QDialog* createUserGuideDialog() const сделать virtual QHelpEngine* getUserGuide(). Сейчас справки никакой нет и это не важно, но для крупных приложений она понадобится. [легко, но надо подумать надо ли]
- Свой специальный виджет для интервального ввода. Было бы невероятно круто. [сложно]
- Ассоциация горячих клавиш с какими-то действиями. Например, F5 - отправить модель на сервер. [средне]
- Улучшить диалог подключения, чтобы была возможность подключаться к защищенному серверу, который требует авторизацию(ключ). Пригодится для каких-то коммерческих клиентов. [средне]
- Под linux я использую стандартные значки(https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html) т.к это улучшает слияние вида приложения с системой, [легко]
    но похоже не все среды рабочего стола реализуют полный набор и вместо некоторых значков могут быть пустые места.
    Надо проверить, что все значки, которые я задал в .ui форме успешно открылись или загрузить свой набор как я делаю под win и wasm. Тогда можно будет убрать некрасивую проверку дефайнами платформы.
- Проверить что нет утечек памяти, связанных с отсутствием Qt::WA_DeleteOnClose, что приводит к тому, что виджет закрывается, но не удаляется. [легко]
- Возможно, лучше разбить OutputWindow на несколько отдельных окон: вывод успешного результата, класс наследник QProgressDialog, и QMessageBox для вывода ошибки.
